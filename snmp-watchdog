#! /usr/bin/perl
# Author: Angus Warren
# Date: March 2021
# Description: Runs as an extension to snmpd to read EdgeOS load balance status
#
# snmpd.conf should have a line like this: 
#pass .1.3.6.1.4.1.56751.1.1 /config/scripts/snmp-watchdog
#sudo invoke-rc.d snmpd restart
#
## Example output
##  snmpwalk -v 2c -On -c $SECRET $HOSTNAME .1.3.6.1.4.1.56751.1.1
# .1.3.6.1.4.1.56751.1.1.0 = STRING: "LB_wan1primary"
# .1.3.6.1.4.1.56751.1.1.0.0 = STRING: "pppoe0"
# .1.3.6.1.4.1.56751.1.1.0.0.0 = STRING: "OK"
# .1.3.6.1.4.1.56751.1.1.0.1 = STRING: "pppoe1"
# .1.3.6.1.4.1.56751.1.1.0.1.0 = STRING: "OK"
# .1.3.6.1.4.1.56751.1.1.1 = STRING: "LB_wan2primary"
# .1.3.6.1.4.1.56751.1.1.1.0 = STRING: "pppoe0"
# .1.3.6.1.4.1.56751.1.1.1.0.0 = STRING: "OK"
# .1.3.6.1.4.1.56751.1.1.1.1 = STRING: "pppoe1"
# .1.3.6.1.4.1.56751.1.1.1.1.0 = STRING: "OK"


use strict;
use warnings;
#use Data::Dump 'dd';

my $BASE = '.1.3.6.1.4.1.56751.1.1';
my $FORCECACHE = 0;
 
sub load_watchdog_status {
    # This will load the watchdog status and cache it to file.
    # If there's a cached version from the last 30 seconds, it 
    # will use that rather than re-running the status command.

    my $TMPFILE = "/tmp/watchdogstatus-$ENV{USER}";
    my $maxage = 1/24/60/60*30; # 30 seconds

    if ($FORCECACHE == 0 && (! -f $TMPFILE || -M $TMPFILE > $maxage)) {
        # refresh the cached watchdog status output
        my $cmd = "/config/scripts/show-watchdog-status > $TMPFILE";
        system($cmd);
    }
    my $output;
    open(my $fh, '<', $TMPFILE)
        or die "Unable to open $TMPFILE: $!";
    {
        local $/;
        $output = <$fh>;
    }
    close($fh);
    return $output;
}

sub parse_status {
    # Parses the watchdog status output into an Array of Arrays.
    # Returns something like this:
    # (
    #   ["LB_wan1primary", [["pppoe0", "OK"], ["pppoe1", "OK"]]],
    #   ["LB_wan2primary", [["pppoe0", "OK"], ["pppoe1", "OK"]]],
    # )

    my $block = shift;
    my @groups;
    while( $block =~ /^Group ([^\n]*)\n((?:.|\n)*?)(?=Group |\z)/gm ) {
        my $group = $1;
        my $ifaceblock = $2;
        my @interfaces;
        while ( $ifaceblock =~ /^  (.+)\n  status: ([^\n]*)/gm ) {
            my $iface = $1;
            my $status = $2;
            push(@interfaces, [$iface, $status]);
        }
        push (@groups, [$group, \@interfaces]);
    }
    return @groups;
}

sub print_snmp_string {
    my $oid = shift;
    my $string = shift;
    print "$oid\nstring\n$string\n";
}

sub get_oid {
    my($oid, $data) = @_;
    my @groups = parse_status($data);

    my $output = '';
    if ($oid eq $BASE) {
        $output = "Watchdog Status";
    } else {
        my $suffix = $oid;
        $suffix =~ s/^$BASE\.//;
        my @split = split(/\./, $suffix);
        my $len = scalar @split;

        if (@split == 1) {
            # Get the group name
            $output = $groups[$split[0]][0];
        } elsif (@split == 2) {
            # Get the interface name
            $output = $groups[$split[0]][1][$split[1]][0];
        } elsif (@split == 3 && $split[2] == "0") {
            # Get the interface status
            $output = $groups[$split[0]][1][$split[1]][1];
        }
    }
    if (length $output) {
        print_snmp_string($oid,$output);
    }
}

sub get_next {
    my($oid, $data) = @_;
    my @groups = parse_status($data);
    my $nextoid = '';
    if ($oid eq $BASE) {
        # for the top level, get the first group
        $nextoid = "$BASE.0"
    } else {
        my $suffix = $oid;
        $suffix =~ s/^$BASE\.//;
        my @split = split(/\./, $suffix);
        my $len = scalar @split;

        if (@split == 1) {
            # for a group, return the first interface
            $nextoid = "$oid.0";
        } elsif (@split == 2) {
            # for an interface, return the status
            $nextoid = "$oid.0";
        } elsif (@split == 3 && $split[2] == "0") {
            # for the interface status, check to see if we need to 
            # go to the next interface or the next group.
            my $groupindex = $split[0];
            my $ifaceindex = $split[1];
            my @ifaces = $groups[$groupindex][1];
            if ($ifaceindex < @ifaces) {
                # return the next interface
                $ifaceindex++;
                $nextoid = "$BASE.$groupindex.$ifaceindex";
            } else {
                # return the next group
                $groupindex++;
                $nextoid = "$BASE.$groupindex";
            }
        }
    }
    get_oid($nextoid, $data);
}

sub usage {
    warn "Usage: $0 [--force-cache] {-g|-n} $BASE\[suffix]\n";
    exit 1;
}

if (@ARGV < 2) {
    usage();
    exit 1;
}

my $act = shift;
if ($act eq '--force-cache') {
    $FORCECACHE = 1;
    $act = shift;
}
my $oid = shift;
my $data = load_watchdog_status();

if ($act eq '-g') {
    get_oid($oid, $data);
} elsif ($act eq '-n') {
    get_next($oid, $data);
} else {
    usage();
}
